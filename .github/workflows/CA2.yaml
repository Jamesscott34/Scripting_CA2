name: CA2

# CI workflow for the CA2 Secure Programming & Scripting project.
# It runs tests and security tooling in both secure and insecure modes,
# and then repeats key tests inside the Docker environment.

on:
  # Run on every push to main and on pull requests targeting main.
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

# Minimum permissions required so SARIF upload can talk to the Code Scanning API.
permissions:
  contents: read
  security-events: write

jobs:
  test-and-security:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ["3.11", "3.12"]

    steps:
      # 1) Get the source code.
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2) Prepare Python runtime.
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      # 3) Cache pip downloads to speed up subsequent runs.
      - name: Cache pip
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          # Only hash the root requirements.txt; the app-specific file was removed.
          key: ${{ runner.os }}-pip-${{ hashFiles('requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      # 4) Install top-level dependencies (including security tooling deps).
      - name: Install root requirements.txt
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      # 5) Install additional tooling (Bandit for SAST), ensuring SARIF support.
      - name: Install Bandit (with SARIF support)
        run: |
          python -m pip install --upgrade "bandit[sarif]>=1.7.8"

      # 6) Run dependency vulnerability scanners (pip-audit and Safety).
      - name: Run pip-audit
        run: |
          pip install pip-audit
          pip-audit --strict

      - name: Run Safety
        run: |
          pip install safety
          safety check --bare

      # 7) Run Django tests against a fresh SQLite database in SECURE mode.
      #    SECURE_MODE=secure enables all protections; TEST_MODE=secure ensures
      #    Task 2 integration tests only exercise the secure path.
      - name: Run Django tests (secure mode, SQLite)
        working-directory: ca2_secure_website
        env:
          SECURE_MODE: secure
          USE_SQLITE: 1
        run: |
          python manage.py makemigrations app
          python manage.py migrate
          TEST_MODE=secure python manage.py test

      # 8) Run Django tests again but in INSECURE mode.
      #    SECURE_MODE=insecure switches to the intentionally vulnerable paths
      #    (raw SQL, XSS-friendly output, CSRF disabled) so tests and scripts
      #    can demonstrate real issues.
      - name: Run Django tests (insecure mode, SQLite)
        working-directory: ca2_secure_website
        env:
          SECURE_MODE: insecure
          USE_SQLITE: 1
        run: |
          TEST_MODE=insecure python manage.py test

      # 9) Run Bandit SAST and upload SARIF for GitHub code scanning.
      - name: Run Bandit SAST (SARIF)
        run: |
          # --exit-zero ensures CI continues even if Bandit finds issues;
          # the findings are still captured in the SARIF report for code scanning.
          python -m bandit -r ca2_secure_website -f sarif -o bandit.sarif --exit-zero

      - name: Upload Bandit SARIF
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: bandit.sarif

      # 10) Build and start the Docker Compose stack (web + db) in SECURE mode.
      #     This ensures the Dockerised app can be built and run successfully.
      - name: Build and start Docker Compose (secure image)
        working-directory: docker
        env:
          SECURE_MODE: secure
        run: |
          docker --version
          docker compose version
          docker compose up -d --build

      # 11) Build an additional INSECURE image variant using the SECURE_MODE build arg.
      - name: Build insecure Docker image variant
        run: |
          docker build \
            -f docker/Dockerfile \
            --build-arg SECURE_MODE=insecure \
            -t ca2_web:insecure \
            .

      # 12) Scan the secure Docker image with Trivy for container vulnerabilities.
      - name: Scan Docker Image with Trivy
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: "ca2_web:latest"
          format: "table"
          exit-code: "1"

      # 13) Tag Docker image with commit SHA to support rollbacks.
      - name: Tag Docker image
        working-directory: docker
        run: |
          docker tag ca2_web:latest ca2_web:${{ github.sha }}

      # 14) Run Django tests *inside* the Docker web container in both modes.
      #    SECURE_MODE environment variable is passed through to run tests
      #    first in secure, then in insecure mode.
      - name: Run Django tests inside Docker (secure and insecure)
        working-directory: docker
        env:
          PYTHONUNBUFFERED: "1"
        run: |
          docker compose run --rm -e SECURE_MODE=secure web python manage.py test
          docker compose run --rm -e SECURE_MODE=insecure web python manage.py test

      # 15) Run an OWASP ZAP DAST scan against the Dockerised app.
      - name: Run ZAP DAST scan
        run: |
          python task2_scripts/dast_zap.py \
            -t http://127.0.0.1:8000 \
            --auto \
            --fail-on-medium

      # 16) Upload logs and security reports as CI artefacts for CA2 evidence.
      - name: Upload logs and reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          # Use a matrix-specific name so parallel Python versions don't
          # conflict when creating the same artifact on one workflow run.
          name: logs-and-reports-${{ matrix.python-version }}
          # If some matrix jobs don't produce all log folders, don't fail the workflow.
          if-no-files-found: ignore
          path: |
            logs
            logs/json_logs
            logs/excel
            logs/zap_reports

      # 17) Always stop containers and remove volumes to keep CI clean.
      - name: Stop Docker Compose and clean volumes
        if: always()
        working-directory: docker
        run: |
          docker compose down -v

